# First level cache and Second level cache in Hibernate
1차 캐시와 2차 캐시

## JPA와 Hibernate    
JPA(Java Persistence API)는 자바 ORM 기술에 대한 API 표준 명세다. 쉽게 이야기하면 javax.persistence 패키지에 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스를 모아둔 것이다. 따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다.  

Hibernate는 JPA를 구현한 라이브러리다. javax.persistence 패키지에 포함된 EntityManagerFactory, EntityManager, EntityTransaction을 각각 SessionFactory, Session, Transaction으로 상속받아 구현하고 있다.

## 1차 캐시

> 네트워크를 통해 데이터베이스에 접근하는 시간 비용은 애플리케이션 서버에서 내부 메모리에 접근하는 시간 비용보다 수만에서 수십만 배 이상 비싸다. 따라서 조회한 데이터를 메모리에 캐시해서 데이터베이스에 접근하는 횟수를 줄이면 애플리케이션 성능을 획기적으로 개선할 수 있다.  

영속성 컨텍스트 내부에는 엔티티를 보관하는 저장소가 있는데 이것을 1차 캐시라 한다. 일반적인 웹 애플리케이션 환경은 트랜잭션을 시작하고 종료할 때까지만 1차 캐시가 유효하다. 따라서 애플리케이션 전체로 보면 데이터베이스 접근 횟수를 획기적으로 줄이지는 못한다.

엔티티 매니저로 조회하거나 변경하는 모든 엔티티는 1차 캐시에 저장된다. 트랜잭션을 커밋하거나 플러시를 호출하면 1차 캐시에 있는 엔티티의 변경 내역을 데이터베이스에 동기화 한다.

### 동작 방식
1차 캐시의 동작 방식은 다음과 같다.
1. 최초 조회할 때 1차 캐시에 엔티티가 없으므로
2. 데이터베이스에서 엔티티를 조회해서
3. 1차 캐시에 보관하고
4. 1차 캐시에 보관한 결과를 반환한다.
5. 이후 같은 엔티티를 조회하면 1차 캐시에 같은 엔티티가 있으므로 데이터베이스를 조회하지 않고 1차 캐시의 엔티티를 그대로 반환한다.

### 특징
1차 캐시의 특징은 다음과 같다.
- 같은 엔티티가 있으면 해당 엔티티를 그대로 반환한다. 객체 동일성(a == b)를 보장한다.
- 기본적으로 영속성 컨텍스트 범위의 캐시다. 컨테이너 환경에서는 트랜잭션 범위의 캐시, OSIV를 적용하면 요청 범위의 캐시다.

## 2차 캐시
하이버네이트를 포함한 대부분의 JPA 구현체들은 애플리케이션 범위의 캐시를 지원하는데 이것을 2차 캐시라 한다. 2차 캐시를 사용하면 애플리케이션 전체의 조회 성능을 향상시킬 수 있다.

애플리케이션에서 공유하는 캐시를 JPA는 공유 캐시 혹은 2차 캐시라 부른다. 2차 캐시는 애플리케이션 범위의 캐시이기 때문에 애플리케이션을 종료할 때까지 유지된다. 분산 캐시나 클러스터링 환경의 캐시는 애플리케이션보다 더 오래 유지될 수 있다.

2차 캐시를 적용하면 엔티티 매니저를 통해 데이터를 조회할 때 우선 2차 캐시에서 찾고 없으면 데이터베이스에서 찾는다. 

### 동작 방식
2차 캐시의 동작 방식은 다음과 같다.
1. 영속성 컨텍스트는 엔티티가 필요하면 2차 캐시를 조회한다.
2. 2차 캐시에 엔티티가 없으면 데이터베이스를 조회해서
3. 결과를 2차 캐시에 보관한다.
4. 2차 캐시는 자신이 보관하고 있는 엔티티를 복사해서 반환한다.
5. 2차 캐시에 저장되어 있는 엔티티를 조회하면 복사본을 만들어 반환한다.

2차 캐시는 동시성을 극대화하려고 캐시한 객체를 직접 반환하지 않고 복사본을 만들어서 반환한다. 만약 캐시한 객체를 그대로 반환하면 여러 곳에서 같은 객체를 동시에 수정하는 문제가 발생할 수 있다. 이 문제를 해결하려면 객체에 락을 걸어야 하는데 이렇게 하면 동시성이 떨어질 수 있다. 락에 비하면 객체를 복사하는 비용은 아주 저렴하다. 따라서 2차 캐시는 원본 대신에 복사본을 반환한다.

### 특징
2차 캐시의 특징은 다음과 같다.
- 영속성 유닛 범위의 캐시다.
- 조회한 객체를 그대로 반환하는 것이 아니라 복사본을 만들어서 반환한다.
- 데이터베이스 기본 키를 기준으로 캐시하지만 영속성 컨텍스트가 다르면 객체 동일성(a == b)을 보장하지 않는다.

## 참고
https://medium.com/swlh/what-is-hibernate-caching-introduction-of-level-1-level-2-cache-8ea7339a5052  
https://www.java67.com/2017/10/difference-between-first-level-and-second-level-cache-in-Hibernate.html#:~:text=The%20main%20difference%20between%20the,and%20available%20to%20all%20Sessions.  
