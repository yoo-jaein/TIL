# Persistence Context
영속성 컨텍스트

## 정의
JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트이다. 어플리케이션과 데이터베이스 사이에 존재하는 논리적인 개념으로 엔티티를 저장하는 환경을 의미한다. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.  

```java
em.persist(member);
```

위에서 사용된 persist() 메서드는 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

## 특징
1. 식별자 값(@Id)  
영속성 컨텍스트는 엔티티를 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)으로 구분한다. 따라서 영속 상태 엔티티는 반드시 식별자 값이 있어야 한다. 식별자 값이 없으면 예외가 발생한다.  
   
2. 영속성 컨텍스트와 데이터베이스 저장  
영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 데이터베이스에 저장될까? JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된/변경된 엔티티를 데이터베이스에 반영한다. 이를 flush라 한다.

## flush : 영속성 컨텍스트가 실제 데이터베이스에 반영되는 시점
영속성 컨텍스트에 존재하는 엔티티는 flush() 메서드가 호출되었을 때 데이터베이스에 반영된다.

flush() 메서드는 다음의 조건에서 호출된다.
1. entityManger.flush()로 직접 호출
2. 트랜젝션 커밋(commit)시 자동 호출
3. JPQL 쿼리 실행시 자동 호출

## 장점
1. 1차 캐시  
em.find()를 호출하면 우선 영속성 컨텍스트의 1차 캐시에서 식별자 값으로 엔티티를 찾는다. 만약 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다. 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다. 그리고 그것을 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다. 이를 통해 성능상 이점을 누릴 수 있다.  

2. 동일성 보장  
영속성 컨텍스트는 find()를 반복해서 호출해도 언제나 동일한 엔티티 인스턴스를 반환한다.  

3. 쓰기 지연  
엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부의 쿼리 저장소에 Insert SQL을 모아둔다. 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연이다.  
   
4. 변경 감지  
JPA에서 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다. update() 메서드는 없다. 이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지라 한다. 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.  
   
5. 지연 로딩  
지연 로딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제로 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다. 모든 연관관계에 지연 로딩을 사용하는 것이 좋다. 어느정도 개발이 완료됐을 때 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하면 된다. 

## 참고
자바 ORM 표준 JPA 프로그래밍 3장, 8장