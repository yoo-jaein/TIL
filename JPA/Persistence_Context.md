# Persistence Context
영속성 컨텍스트

## 정의
JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트이다. 어플리케이션과 데이터베이스 사이에 존재하는 논리적인 개념으로 엔티티를 저장하는 환경을 의미한다. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.  

```java
em.persist(member);
```

위에서 사용된 persist() 메서드는 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다. 이처럼 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

## 특징
1. 식별자 값(@Id) : 영속성 컨텍스트는 엔티티를 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)으로 구분한다. 따라서 영속 상태 엔티티는 반드시 식별자 값이 있어야 한다. 식별자 값이 없으면 예외가 발생한다.  
   
2. 영속성 컨텍스트와 데이터베이스 저장 : 영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 데이터베이스에 저장될까? JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된/변경된 엔티티를 데이터베이스에 반영한다. 이를 flush라 한다.

## flush : 영속성 컨텍스트가 실제 데이터베이스에 반영되는 시점
영속성 컨텍스트에 존재하는 엔티티는 flush() 메서드가 호출되었을 때 데이터베이스에 반영된다. flush() 메서드는 다음의 조건에서 호출된다.
1. entityManger.flush()로 직접 호출
2. 트랜젝션 커밋(commit)시 자동 호출
3. JPQL 쿼리 실행시 자동 호출

## 장점
1. 1차 캐시 : em.find()를 호출하면 우선 영속성 컨텍스트의 1차 캐시에서 식별자 값으로 엔티티를 찾는다. 만약 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다. 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다. 그리고 그것을 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다. 이를 통해 성능상 이점을 누릴 수 있다.
2. 동일성 보장 : 영속성 컨텍스트는 find()를 반복해서 호출해도 언제나 동일한 엔티티 인스턴스를 반환한다.
3. 쓰기 지연 : 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부의 쿼리 저장소에 Insert SQL을 모아둔다. 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연이다.
4. 변경 감지 : JPA에서 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다. update() 메서드는 없다. 이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지라 한다. 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
5. 지연 로딩 : 지연 로딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제로 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다. 모든 연관관계에 지연 로딩을 사용하는 것이 좋다. 어느정도 개발이 완료됐을 때 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하면 된다. 

## 영속성 컨텍스트와 엔티티의 생명 주기
### 1. 비영속(new/transient)
```java
Member member = new Member("member1", 회원1);
```
비영속 상태는 영속성 컨텍스트와 관련이 없는 순수한 자바 객체 상태이다.

### 2. 영속(managed)
```java
em.persist(member);
em.find(1, Member.class);
```
엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장했다. 영속 상태는 이렇게 영속성 컨텍스트가 관리하는 상태를 말한다. em.find()나 JPQL을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태다. 

### 3. 준영속(detached)
```java
em.detach(member);
//...
em.close();
//...
em.clear();
```
엔티티가 영속성 컨텍스트에 저장되었다가 현재는 분리된 상태다. 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능(1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연 로딩 등)을 사용할 수 없다. 특정 엔티티를 준영속 상태로 만들려면 em.detach()를 호출해서 엔티티를 넘겨주면 된다. detach() 메서드를 호출하는 순간 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거된다. em.close()를 호출해서 영속성 컨텍스트를 닫거나 em.clear()를 호출해서 영속성 컨텍스트를 초기화하면 영속성 컨텍스트가 관리하던 모든 엔티티는 준영속 상태가 된다. 사실 개발자가 직접 엔티티를 준영속 상태로 만드는 일은 드물다.  

```java
public <T> T merge(T entity);
```
```java
Member mergeMember = em.merge(detachedMember);
```
준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합(merge)를 사용하면 된다. merge() 메서드는 준영속 상태의 엔티티를 전달받아서 그 정보로 새로운 영속 상태의 엔티티를 반환해준다. 파라미터로 넘어온 엔티티의 식별자 값으로 영속성 컨텍스트를 조회하고 찾는 엔티티가 없으면 데이터베이스에서 조회한다. 만약 데이터베이스에서도 발견하지 못하면 새로운 엔티티를 생성해서 병합한다. merge는 식별자 값만 확인하기 때문에 들어오는 엔티티가 준영속인지 비영속인지 신경 쓰지 않는다. 식별자 값으로 엔티티를 조회할 수 있으면 불러서 병합하고 조회할 수 없으면 새로 생성해서 병합한다. 

### 4. 삭제(removed)
```java
em.remove(member);
```
엔티티가 영속성 컨텍스트와 데이터베이스에서 삭제된 상태다. 

## 참고
자바 ORM 표준 JPA 프로그래밍 3장, 8장