# MySQL InnoDB Clustering Index

## 클러스터링 인덱스
클러스터링(Clustering)이란 여러 개를 하나로 묶는다는 의미로 주로 사용된다. 테이블의 레코드를 프라이머리 키를 기준으로 비슷한 것들끼리 묶어서 저장하는 인덱스를 클러스터링 인덱스라 한다. 프라이머리 키 값에 대한 의존도가 높기 때문에 프라이머리 키를 신중히 결정해야 한다. 클러스터링의 기준이 되는 프라이머리 키를 클러스터링 키라고도 표현한다. MySQL 서버에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원하며 나머지 스토리지 엔진에서는 지원되지 않는다.  

클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르다. 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다. 프라이머리 키 값으로 묶어서 저장하기 때문에 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치도 바뀌어야 한다.  

## 클러스터링 테이블
클러스터링 인덱스의 구조 자체는 일반 B-Tree와 비슷하다. 하지만 세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리, 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 저장되어 있다. 그래서 클러스터링 인덱스를 클러스터링 테이블이라고도 부른다.  

## 클러스터링 키 선정하기
프라이머리 키가 없는 InnoDB 테이블은 어떻게 구성될까? InnoDB는 클러스터링 인덱스를 만들 때 다음의 우선순위대로 클러스터링 키를 선택한다. 
1. 프라이머리 키가 있으면 프라이머리 키를 클러스터링 키로 선택한다.
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째를 클러스터링 키로 선택한다.
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 다음 클러스터링 키로 선택한다.

NOT NULL 옵션의 유니크 인덱스가 없으면 InnoDB 스토리지 엔진이 내부적으로 레코드의 일련번호 컬럼을 생성한다. 이렇게 추가된 값은 사용자에게 노출되지 않고 쿼리 조건으로도 활용할 수 없다. 그렇기 때문에 가능하면 프라이머리 키를 명시적으로 생성하는 것이 좋다.

## 클러스터링되지 않는 테이블과 비교
MyISAM이나 MEMORY 테이블같이 클러스터링되지 않은 테이블의 데이터 레코드는 INSERT될 때 데이터 파일의 끝이나 임의의 빈 공간에 저장되고, 한 번 저장된 위치는 절대 바뀌지 않는다. 레코드가 저장된 주소는 MySQL 내부적으로 레코드를 식별하는 아이디로 구분된다. 이 아이디를 ROWID라고 하는데, MyISAM이나 MEMORY 테이블의 프라이머리 키나 세컨더리 인덱스의 키는 이 ROWID를 이용해서 실제 데이터 레코드에 접근할 수 있다.  

InnoDB 테이블의 세컨더리 인덱스는 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현돼 있다. 만약 InnoDB에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면 프라이머리 키(클러스터링 키)가 변경될 때마다 데이터 주소가 바뀌고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다. 이런 오버헤드를 막기 위해 프라이머리 키 값을 저장한다.  

그렇기 때문에 InnoDB 테이블의 검색은 MyISAM 테이블의 검색과 조금 다르다. InnoDB 테이블은 세컨더리 인덱스에서 검색해서 레코드의 프라이머리 키 값을 확인한 다음, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져온다. 반면 MyISAM 테이블은 세컨더리 인덱스에서 검색해서 레코드의 주솟값을 확인한 다음, 레코드의 주소를 이용해서 최종 레코드를 가져온다.

## 클러스터링 인덱스의 장단점
### 장점
- 프라이머리 키로 검색할 때 성능이 빠르다. 특히, 프라이머리 키를 범위 검색하는 경우 매우 빠르다.
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 커버링 인덱스가 될 경우가 많다.

### 단점
- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체 인덱스의 크기가 커진다.
- 세컨더리 인덱스를 검색한 다음 프라이머리 키로 다시 한 번 검색해야 한다.

## 참고
Real MySQL 8.0 1권 8장  