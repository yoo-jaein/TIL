# DynamoDB review
DynamoDB 사용 후기

## 배경
신규 프로젝트의 데이터베이스로 DynamoDB를 사용하게 되었다. NoSQL를 직접 써보는 것은 처음이라 기대가 됐다. 

## 첫 번째 문제 : 복잡한 쿼리와 페이징 기능
내가 개발하는 백오피스에서는 다양한 검색 조건(유저별 조회, 카테고리별 조회, 통계 조회 등)과 페이징 기능이 필요했다. 하지만 DynamoDB의 자체 기능만으로는 복잡한 쿼리와 검색결과 중 몇 번째 페이지에 접근하는 형태의 페이징이 어렵다. 기본적으로 DynamoDB는 1MB '용량 단위'의 페이징을 제공하기 때문이다. 팀장님은 개발 시작 전부터 페이징 이슈를 인지하고 ElasticSearch를 도입할 것을 제시해주셨다. 이미 DynamoDB와 ElasticSearch를 함께 사용한 사례가 많았기 때문에 개발하는데 큰 어려움은 없었다.

## 첫 번째 해결 : ElasticSearch 도입
데이터 생성, 삭제, 업데이트는 DynamoDB를 직접 이용하고, 조회의 경우 ElasticSearch(OpenSearch)를 이용하기로 했다. 데이터의 흐름은 아래와 같다.

```text
DynamoDB - DynamoDB Stream - AWS Lambda - ElasticSearch
```
1. DynamoDB 테이블에 데이터가 생성/삭제/업데이트되면
2. DynamoDB Stream 기능이 이벤트를 감지하고
3. 등록된 AWS Lambda 함수를 호출한다.
4. Lambda 함수에서 ElasticSearch에 데이터 동기화를 시도한다.

### DynamoDB Stream
DynamoDB 테이블의 데이터에 변경사항(생성/삭제/업데이트)이 발생하면 이를 이벤트 스트리밍 형식으로 처리할 수 있는 기능이다. 이벤트가 발생하면 등록된 람다 함수를 호출하게 되고 람다 함수에서 이벤트를 핸들링한다. 람다 함수가 실패할 경우 데이터가 만료될 때까지 (최대 7일) 실패한 레코드를 처리하려고 시도하기 때문에 안정성이 높다.

### ElasticSearch QueryBuilder
```java
BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery()
    .must(QueryBuilders.matchQuery("name", name))
    .must(QueryBuilders.termQuery("isVisible", true));

NativeSearchQuery nativeSearchQuery = new NativeSearchQueryBuilder()
    .withQuery(boolQueryBuilder)
    .build();
```
ElasticSearch QueryBuilder를 이용하면 페이징이나 정렬, 복잡한 조건 쿼리를 자바 코드 기반으로 편하게 작성할 수 있다. 

## 부작용
이렇게 검색 조건과 페이징은 해결되었으나 부작용을 피할 순 없었다. 새로운 러닝커브와 관리포인트가 생기고 DynamoDB의 대표적인 장점으로 꼽히는 ms단위의 실시간 조회가 ElasticSearch의 초단위 준실시간으로 변했다.

## 참고
https://dev.classmethod.jp/articles/dynamodb-stream-elasticsearch/

## 두 번째 문제 : 피크 트래픽 제한 + 핫 파티션
백오피스에서는 데이터에 연관된 대상자가 담긴 파일을 업로드하는 기능이 있었다. 파일에는 몇십, 몇백명부터 최대 70만명의 데이터가 들어있을 수 있다. 서버에서는 업로드된 파일은 따로 저장하지 않고 필요한 데이터만 파싱하여 어딘가에 저장해둬야 했다. 처음엔 Redis에 List 형식으로 저장시켰다. 중간에 Redis가 DynamoDB 테이블로 변경되면서 문제가 발생했다.  

5만명이 담긴 파일을 처리하는데 50,000건 중 25,000건이 실패했다. 1만명이 담긴 파일을 처리하는데 10,000건 중 5,000건이 실패했다. 최대치에 한참 못 미치는 양인데도 데이터의 절반이 날아갔다. 원인은 DynamoDB의 피크 트래픽 제한이었다. 내가 사용한 온 디맨드 모드의 DynamoDB에서는 오토스케일링이 트래픽 양에 따라 동작하는데 스케일링의 기준치가 이전 피크 트래픽의 2배다. 30분 이내에 이전 피크 트래픽의 2배가 넘는 트래픽이 들어오면 스케일링 범위를 넘어서기 때문에 쓰로틀링이 걸려 요청이 거부되는 것이다. 

사실 더 근본적인 원인은 핫 파티션이였다. 한 테이블의 같은 파티션을 향해 많은 요청이 집중될 때 해당 파티션을 핫 파티션이라 한다. 구체적으론 한 파티션에 3,000 이상의 읽기 혹은 1,000 이상의 쓰기가 발생했을 때 쓰로틀링이 발생할 수 있다. 해당 테이블로 들어가는 몇십만건의 파티션 키는 모두 동일한 String이었으니 핫 파티션 문제도 당연하게 발생한 것이다. 이 부분은 애초에 핫 파티션이 발생하지 않도록 데이터베이스를 설계할 때부터 해시 키를 고르게 설정했어야 했다. 

정신을 부여잡고 백오피스 서버에서 2~3,000건당 1초씩 sleep을 걸어 테스트해봤다. 느리지만 어찌어찌 데이터가 들어가긴 했다. 디버깅을 풀고 실행하니 첫 번째 데이터에서부터 갑자기 NPE가 발생했다. 설마했던 ElasticSearch 조회 속도 이슈가 여기서 터졌다. 서버에서 DynamoDB 테이블에 생성된 데이터가 ElasticSearch으로 동기화되기 전에 접근했기 때문에 에러가 발생한 것이다.  

## 두 번째 해결 : Redis 도입
Redis를 재도입하면서 모든 문제가 깔끔하게 해결되었다. 

### + 스케일링 해결법
스케일링 기준치를 최대 데이터까지 커버할 수 있도록 높이면 쓰로틀링이 해결될 수도 있다. 이 방법은 시도해보지 않았다.

### + 프로비저닝 해결법
프로비저닝이란 사용자의 요구에 맞게 시스템 자원을 할당, 배포해두고 필요할 때 시스템을 즉시 사용할 수 있는 상태로 준비해 두는 것이다. DynamoDB에 프로비저닝 모드를 적용해서 초당 읽기/쓰기 횟수를 지정해둘 수 있다. 이 방법도 시도해보지 않았다.

### + 핫 파티션 해결법
핫 파티션을 피하기 위한 방법도 더 구체적으로 찾아봤다.

1. 테이블 설계를 잘 한다. 해시 키를 기준으로 파티션이 나눠지기 때문에 데이터를 균형있게 분산시켜줄 데이터를 해시 키로 골라야 한다.
2. 골고루 분산시켜줄 데이터가 없다면 샤딩을 이용한다. 해시 키에 접미사를 붙여서 파티션을 분산시키는 설계를 샤딩이라고 부른다. 난수 샤딩이나 해시 샤딩을 이용한다.

### 참고
https://aws.amazon.com/ko/premiumsupport/knowledge-center/dynamodb-table-throttled/
https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html
https://velog.io/@milkcoke/DynamoDB  
https://aerocode.net/298  

## 느낀 점
### 장점
1. AWS에서 모든 것을 관리해주는 완전 관리형 서비스다.
2. 어떤 규모에서도 10ms 미만의 빠른 레이턴시가 보장된다.
3. DB에 대한 상태와 통계 정보를 그래프로 쉽게 확인할 수 있다.
4. 오토스케일링을 해준다.
5. 스케일 아웃(수평 확장)이 쉽다.

### 단점
1. 원하는 페이징(검색결과 중 몇 번째 페이지에 접근하는 형태)이 어렵다.
2. 감당할 수 있는 트래픽의 최대치를 넘어가면 요청을 거부해버린다.
3. 조인이 불가능하다. 테이블을 하나만 사용하거나 혹은 테이블들이 독립적으로 운용될 것을 권장한다.

### 결론
데이터베이스는 사용하기 전에 깊게 공부해보자. 그리고 DynamoDB는 정말 적합한 곳에만 쓰자. 
