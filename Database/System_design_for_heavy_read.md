# System design for heavy read
Read 부하를 줄이기 위한 시스템 디자인하기

## 문제 상황
Read 부하(Select 쿼리)가 매우 많이 발생하는 상황에서 데이터베이스나 서비스가 죽지 않고 정상적으로 동작하려면 어떻게 해야 할까? 데이터베이스 부하를 어떻게하면 줄일 수 있을까?  

## 관점 1: 쿼리
- 쿼리가 실시간으로 처리될 필요가 없다면 배치로 처리하자.
- 발생하는 Select 쿼리는 최적화되었는가? 
  - 혹시 서브쿼리가 들어있지 않은가? 필요한 데이터만 프로젝션하고 있는가? (Select * 는 최악이다) [커버링 인덱스](https://stricky.tistory.com/441)를 사용하고 있는가?
  - 쿼리 내의 연산 중에 서버단에서 처리할 수 있는 것들은 서버의 로직으로 변경하자.
- B-tree, hash, bitmap 등 데이터에 적합한 인덱스를 잘 타고 있는가? 
- 불필요한 Select 쿼리가 있는가? 
  - 조인해서 한 번의 Select 쿼리로 가져올 수 있는 데이터들인데 나눠서 쿼리를 날리고 있진 않는가?

## 관점 2: 데이터베이스
- 데이터베이스 서버의 하드웨어 성능을 높이자. (Scale up)
- master 데이터베이스를 복제한 replica 데이터베이스를 만들자. (Scale out)
- 데이터베이스 서버의 위치를 물리적으로 가깝게 하자.
- 클라이언트단에서 HTTP 캐싱을 고려해보자.
- 조회하려는 데이터가 변하지 않는 정적 데이터인가? 
  - 그렇다면 캐싱하자. Redis 등 속도가 빠른 인메모리 캐시를 고려한다. 예를 들어, 유저가 요청한 url이 Redis key에 있는지 먼저 체크하고, 없다면 데이터베이스를 조회한 후 url과 데이터를 Redis에 저장한 뒤에 응답한다. 이후 만료 시간이 지나기 전까지 해당 url은 Redis의 value를 사용한다.
- 조회하려는 데이터가 실시간성을 보장해야 하는가?
  - 지연이 허용되지 않는(low latency) 중요한 쿼리라면 반드시 master 데이터베이스를 봐야한다. 그렇다면 데이터베이스 레벨에서 수직적/수평적 파티셔닝이나 샤딩을 고려한다.
- 커맨드 쿼리를 분리할 수 있는가? (CQRS)
  - [CQRS](https://freedeveloper.tistory.com/399)란 명령(시스템의 데이터를 변경)하는 구성 요소와 쿼리(시스템의 데이터를 조회)하는 구성 요소를 나누는 것이다. 조인된 응답 결과 자체를 하나의 도큐먼트로 저장한다. 예를 들어, RDB에 데이터가 삽입되면 조회 성능이 빠른 MongoDB에 조회될 결과 자체를 동기화시켜두고 MongoDB에서 조회한다.
- 혹시 모를 데이터베이스 장애에 대비하기 위해 [데이터베이스 프록시](https://notemusic.tistory.com/52)를 이용하거나 백업을 자주 한다.
  - [Amazon RDS Proxy](https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/rds-proxy.html)
