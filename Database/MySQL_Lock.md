# MySQL Lock
MySQL에서 사용되는 락은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다. 

## MySQL 엔진 레벨의 락
MySQL 엔진은 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분이다. MySQL 엔진 레벨의 락은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 락은 스토리지 엔진 간 영향을 미치지는 않는다. MySQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락 외에도 테이블의 구조를 잠그는 메타데이터 락, 사용자의 필요에 맞게 사용할 수 있는 네임드 락 기능을 제공한다.

### 글로벌 락
글로벌 락은 다음 명령으로 획득할 수 있다.
```mysql
FLUSH TABLES WITH READ LOCK 
```
글로벌 락을 거는 위 명령은 실행과 동시에 MySQL 서버에 존재하는 모든 테이블을 잠근다. 글로벌 락은 MySQL에서 제공하는 락 중에 가장 범위가 크다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우, 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다. 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다. 그래서 웹 서비스용으로 사용되는 서버에서는 가급적 사용하지 않는 것이 좋다.  

MyISAM이나 MEMORY 테이블에 대해 mysqldump로 백업을 받아야 할 때 글로벌 락을 사용한다. 위 명령은 테이블에 락을 걸기 전에 먼저 테이블을 플러시한다. 그렇기 때문에 테이블에 실행 중인 모든 종류의 쿼리가 완료돼야 한다. 만약 장시간 SELECT 쿼리가 실행되고 있다면 위 명령은 그 쿼리가 종료될 때까지 기다려야 한다. 이 상황에서 최악의 경우 MySQL 서버의 모든 테이블에 대한 INSERT, UPDATE, DELETE 쿼리가 아주 오랜 시간 동안 실행되지 못하고 기다릴 수도 있다.  

### 백업 락
InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다. MySQL 8.0부터 InnoDB가 기본 스토리지 엔진으로 채택되면서 Xtrabackup이나 Enterprise Backup과 같은 백업 툴들의 실행을 위해 백업 락이 새로 도입됐다. 특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 인증 관련 정보를 변경할 수 없게 된다. 하지만 일반적인 테이블의 데이터 변경은 허용된다.

### 테이블 락
테이블 락은 다음 명령으로 획득할 수 있다.
```mysql
LOCK TABLES table_name [ READ | WRITE ]
```
테이블 락은 개별 테이블 단위로 설정되는 잠금이다. 테이블 락은 MyISAM, InnoDB 스토리지 엔진 모두 동일하게 설정할 수 있다. 위 명령으로 명시적으로 획득한 락은 UNLOCK TABLES 명령으로 잠금을 해제할 수 있다. 특별한 상황이 아니면 명시적으로 락을 거는 경우는 거의 없다.  

묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용된다. 즉, 묵시적인 테이블 락은 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제된다. 하지만 InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 락을 제공하기 때문에 단순한 데이터 변경 쿼리로 테이블 락이 설정되지는 않는다. InnoDB 테이블에서도 테이블 락이 설정되긴 하지만 대부분의 DML 쿼리에서는 무시되고 스키마를 변경하는 DDL 쿼리의 경우에만 영향을 미친다.  

### 네임드 락
네임드 락은 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다. 테이블이나 레코드와 같은 데이터베이스 객체가 아니라 사용자가 지정한 문자열에 대해 획득하고 해제하는 락이다.  

### 메타데이터 락
메타데이터 락은 테이블이나 뷰 등의 데이터베이스 객체 이름이나 구조를 변경하는 경우에 획득하는 락이다. 메타데이터 락은 명시적으로 획득할 수 있는 것이 아니고 RENAME TABLE tab_a TO tab_b 처럼 테이블의 이름을 변경하는 경우 자동으로 획득하는 락이다. RENAME TABLE 명령의 경우 원본 이름과 변경될 이름 모두를 한꺼번에 잠금 설정한다. 

## 스토리지 엔진 레벨의 락
InnoDB 스토리지 엔진은 MySQL 엔진 레벨의 락과 별개로 레코드 기반의 락 기능을 제공한다. MySQL 서버의 information_schema 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 어떤 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있으며, 장시간 잠금을 가지고 있는 클라이언트를 찾아서 종료시킬 수도 있다.

### 레코드 락
레코드 락은 레코드 자체를 잠그는 것을 말한다. 특이한 점은 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다. 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다. 

### 갭 락
갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다. 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 추가되는 것을 제어하는 것이다. 갭 락은 넥스트 키 락의 일부로 자주 사용된다.

### 넥스트 키 락
레코드 락과 갭 락을 합쳐 놓은 형태의 락을 넥스트 키 락이라 한다. 

### 자동 증가 락
MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는 컬럼 속성을 제공한다. 자동 증가 락은 AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우에 테이블 수준에서 사용되는 락이다. 자동 증가 락은 INSERT나 REPLACE 쿼리와 같이 새로운 레코드를 저장하는 쿼리에서만 필요하다. 트랜잭션과 관계없이 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.  

MySQL 5.1 이상부터는 innodb_autoinc_lock_mode라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다. 자동 증가는 값이 한 번 증가하면 절대 줄어들지 않는데, 그 이유는 락을 최소화하기 위해서다. INSERT 쿼리가 실패했더라도 한 번 증가된 값은 그대로 남는다.

## 참고
Real MySQL 8.0 1권 5장