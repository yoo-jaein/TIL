# Transaction

트랜잭션은 논리적인 작업 셋을 모두 완벽하게 처리하거나(Commit), 처리하지 못할 경우에는 원 상태로 복구해서(Rollback) 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다. MySQL 서버에서 MyISAM이나 MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않고, InnoDB 스토리지 엔진은 트랜잭션을 지원한다.

## 트랜잭션의 필요성
데이터베이스가 트랜잭션을 지원하지 않을 때, 부분 업데이트 현상이 발생하면 쓰레기 데이터를 삭제해주는 작업(데이터 클렌징)이 필요할 수 있다. 실행하는 쿼리가 하나뿐이라면 처리 과정이 간단하지만, 2개 이상의 쿼리가 실행되는 경우라면 실패에 대한 재처리 작업이 상당히 복잡해진다.   

## Lock과 트랜잭션
Lock과 트랜잭션은 비슷한 개념 같지만 Lock은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 하나의 회원 정보 레코드를 여러 커넥션에서 동시에 변경하려고 하는데 Lock이 없다면 하나의 데이터를 여러 커넥션에서 동시에 변경할 수 있게 된다. 그러면 해당 레코드의 값은 예측할 수 없는 상태가 된다. Lock은 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.

## 트랜잭션의 특징
- 원자성(Atomicity) : 트랜잭션의 모든 연산은 정상적으로 수행 완료되거나 어떤 연산도 수행되지 않는다.
- 일관성(Consistency) : 트랜잭션이 완료된 후에도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장한다. 
- 독립성(Isolation) : 하나의 트랜잭션 내에서 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못한다. 
- 지속성(Durability) : 트랜잭션이 정상적으로 종료된 다음에는 데이터베이스에 작업의 결과가 영구적으로 저장된다.

## 트랜잭션의 상태
- Active : 트랜잭션이 연산을 실행 중인 상태 
- Failed : 트랜잭션 실행에 오류가 발생해 중단된 상태 
- Partially Committed : 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전인 상태. 트랜잭션이 마지막 연산까지 실행하고 Commit 요청을 한 상태 
- Committed : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태 
- Aborted : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

## 트랜잭션 격리 수준
MySQL 트랜잭션의 격리 수준(isolation level)이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

## Isolation Level의 종류
일반적인 서비스용 데이터베이스는 Read Committed와 Repeatable Read 중 하나를 사용한다. 오라클 같은 DBMS에서는 주로 Read Commiteed를 사용하며 MySQL에서는 Repeatable Read를 주로 사용한다.

### Read Uncommitted(레벨 0)
어떤 트랜잭션의 변경 내용이 Commit이나 Rollback 여부에 상관없이 다른 트랜잭션에서 보인다. 데이터의 일관성을 유지할 수 없기 때문에 일반적인 데이터베이스에서는 거의 사용되지 않는다. Commit 되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상을 Dirty Read라 하고 이를 허용한다. Dirty Read는 데이터가 있었다가 사라지는 현상을 초래하기 때문에 애플리케이션 개발자와 사용자를 혼란에 빠트릴 수 있다.

### Read Committed(레벨 1)
오라클 DBMS에서 기본으로 사용되는 격리 수준이다. Dirty Read 현상이 발생하지 않는다. 어떤 트랜잭션에서 데이터를 변경했더라도 Commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다. Non-Repeatable Read 문제가 발생할 수 있다. 이는 한 트랜잭션에서 같은 쿼리를 두 번 이상 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제 Commit하여 쿼리가 실행될 때마다 다른 결과를 가져오는 현상이다. 일반적인 웹 애플리케이션에서는 크게 문제되지 않을 수 있지만 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수도 있다.

### Repeatable Read(레벨 2)
MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. MySQL 서버에서는 최소 Repeatable Read 격리 수준 이상을 사용해야 한다. 이 수준에서는 Non-Repeatable Read 문제가 발생하지 않는다. InnoDB 스토리지 엔진은 트랜잭션이 Rollback될 가능성에 대비해 변경 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경한다. 이러한 변경 항식을 MVCC(Multi Version Concurrency Control)이라 한다. Repeatable Read는 이 MVCC를 이용해 동일 트랜잭션 내에서는 항상 동일한 결과를 보여줄 수 있게 보장한다. Phantom Read 문제가 발생할 수 있다. 이는 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 SELECT 쿼리에서 없던 레코드가 두 번째 SELECT 쿼리에서 보이는 현상이다. 구체적으로 SELECT ... FOR UPDATE나 SELECT ... FOR SHARE 쿼리의 경우 발생할 수 있다.

### Serializable(레벨 3)
가장 엄격한 격리 수준이기 때문에 동시 처리 성능이 다른 격리 수준보다 떨어진다. InnoDB 테이블에서 기본적으로 순수한 SELECT 작업은 아무런 레코드 Lock 없이 실행된다. 하지만 트랜잭션의 격리 수준이 Serializable이 되면 읽기 작업도 읽기 Lock을 획득해야만 한다. 다른 트랜잭션은 그 레코드를 변경하지 못한다.

## 참고
Real MySQL 8.0 1권 5장