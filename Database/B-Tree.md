# B-Tree

트리 자료 구조는 짧은 시간 내에 데이터를 탐색할 수 있기 때문에 다양한 분야에서 사용된다. MySQL에서는 B-Tree를 사용하여 인덱스를 관리하고 있다. 

## B-Tree의 구성요소
B-Tree를 구성하는 한 개의 데이터를 ```노드(Node)```라고 부른다. 최상단의 노드를 ```루트 노드(Root Node)```, 최하단 노드들을 ```리프 노드(Leaf Node)```, 루트 노드도 아니고 리프 노드도 아닌 중간 노드들을 ```브랜치 노드(Branch Node)```라고 한다. B-Tree를 구성하는 각 노드들은 데이터가 정렬된 상태로 관리되기 때문에 탐색 속도가 빠르다. B-Tree는 이진 탐색 트리(Binary Search Tree)와 유사하지만 한 노드 당 자식 노드를 3개 이상 구성할 수 있다는 점이 다르다.  

## Balanced
```text
   2
  / \
 1   3
```
B-Tree의 B는 Balanced라는 의미를 가지고 있다. 균형잡힌 트리란 루트 노드로부터 모든 리프 노드까지의 거리가 일정한 트리를 말한다. 트리 자료 구조에서 루트 노드로부터 리프 노드까지 거리 중 최대 길이를 ```트리의 높이(Height)```라고 부른다. B-Tree는 루트 노드로부터 모든 리프 노드까지의 거리가 모두 동일하기 때문에 동일한 탐색 시간 O(logN)을 보장한다. 참고로 공간 복잡도는 O(N)이다. 

균형 잡히지 않은 최악의 케이스는 다음과 같다.
```text
1
 \
  2
   \
    3
```
이렇게 트리를 구성하는 노드가 한쪽 방향으로 쏠려있다면 최악의 경우 탐색 시간은 O(N)이 된다. B-Tree를 처음 생성했을 때는 균형잡힌 트리지만 트리에 노드가 삽입되고 삭제되면 위 트리처럼 균형이 서서히 깨지게 될 것이다. 그래서 B-Tree는 노드의 삽입, 삭제가 일어날 때 트리를 재정렬하는 작업을 거치면서 문제를 해결한다. 다만, 이로 인해 일반적인 트리보다 삽입/삭제 성능이 떨어진다.

## B-Tree의 규칙
- 하나의 노드에서 그 노드의 왼쪽 서브 트리는 그 노드의 키 값보다 작은 값, 오른쪽 서브 트리는 큰 값으로 구성된다.
- 한 노드에 M개의 자료가 들어 있다면 M차 B-Tree라고 부른다. 5차 B-Tree는 자식 노드가 최대 5개인 것을 의미한다.
- 루트 노드는 적어도 2개 이상의 자식 노드를 가진다.
- 루트 노드를 제외한 모든 노드는 적어도 M/2개의 자료를 가진다.
- 노드의 자료 수가 N이면 자식 노드의 개수는 N+1이다.
- 각 노드의 자료는 정렬된 상태로 저장되며 중복되지 않는다.

## B+Tree
B+Tree는 B-Tree를 확장한 개념의 트리다. B-Tree와 비교했을 때 B+Tree의 특징은 다음과 같다.
- B-Tree는 모든 노드에 데이터를 저장할 수 있지만, B+Tree는 리프 노드에만 데이터를 저장할 수 있다. 브랜치 노드에 데이터를 저장하지 않으므로 하나의 노드에 더 많은 키를 담을 수 있고, 이로 인해 전체 트리의 높이가 낮아진다.
- 위의 특징 때문에 B-Tree는 풀 스캔할 시 모든 노드를 탐색해야 하지만, B+Tree는 리프 노드만 선형 탐색하면 된다.
- B-Tree는 리프 노드끼리 연결되어 있지 않지만, B+Tree는 리프 노드끼리 Linked List로 연결되어 있다. 리프 노드끼리의 순차 Range 탐색에서 매우 유리하다.

## 참고
https://slenderankle.tistory.com/159  