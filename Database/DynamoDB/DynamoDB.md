# DynamoDB
Amazon DynamoDB는 아마존에서 완전 관리형으로 제공하는 빠르고 유연한 NoSQL 데이터베이스다. DynamoDB를 사용하면 분산 데이터베이스 운영 및 확장의 관리 부담을 덜어 하드웨어 프로비저닝, 설정 및 구성, 복제, 소프트웨어 패치 또는 클러스터 확장에 대해 걱정할 필요가 없다.  아마존에서 인스턴스를 실행하는 데 필요한 모든 인프라를 호스팅해주고, 우리는 읽기 요청, 쓰기 요청, 사용된 스토리지의 바이트에 대해 비용을 지불하기만 하면 된다.

## 장점
- NoSQL이라 스키마 제한이 없다.
- 초당 수 백만개의 요청을 처리할 수 있다. 
- 자동으로 수 백 TB 까지 용량이 확장된다. 
- 기본적으로 데이터의 복사본을 만들어서(AZ당 1개씩, 기본 값으로 총 3개) 고가용성과 내구성을 보장한다.
- 언제 어디서든지 10ms 미만의 지연시간을 보장한다. 
- DAX(Amazon DynamoDB Accelerator(DAX))를 사용하는 경우 지연시간이 micro초까지 감소된다.

## 용량 모드
DynamoDB는 각 테이블에 대해 온디맨드와 프로비저닝 용량 모드를 제공한다. 사용률이 높을지 확신할 수 없어서 예측이 어려운 워크로드의 경우, 사용량에 대해 비용을 지불하는 온디맨드 용량 모드를 사용하는 것이 좋다. 프로비저닝 용량 모드를 사용하는 테이블에는 읽기 및 쓰기 용량(RCU, WCU)을 설정해야 한다. 온디맨드 모드는 프로비저닝 용량 모드보다 RCU, WCU에 대한 비용이 약 6배정도 비싸다. 거기다가 무제한 용량은 아니다. 여전히 제한이 있다. 파티션당 최대 1,000WCU, 3,000RCU까지 제공된다.

## RCU, WCU
프로비저닝 용량 모드를 사용하는 경우 테이블마다 RCU와 WCU를 설정한다.  
- 1 RCU = 4KB 읽기 가능
- 1 WCU = 1KB 쓰기 가능
테이블은 설정된 수치만큼 읽기, 쓰기를 제공할 수 있다. 한 가지 주의해야 할 점은, 테이블 단위로 RCU, WCU를 설정하지만 파티션의 개수만큼 용량이 분산된다는 것이다. 예를 들어, 한 테이블의 WCU가 100이라는 것은 해당 테이블에 파티션이 4개가 있을 때 각 파티션의 WCU가 25라는 뜻이다. 하나의 파티션에 대한 WCU가 100이라는 것이 아니다.

## 기본키
각 테이블은 여러 항목(item)으로 구성된다. 각 항목은 하나 이상의 속성(attribute)을 포함한다. 모든 항목은 파티션 키가 될 하나 이상의 속성을 가진다. 테이블의 모든 CRUD 작업을 할 때는 이 파티션 키를 지정해야 한다. 다이나모디비는 파티션 키를 기반으로 전체 테이블 데이터를 더 작은 파티션으로 분할해서 관리한다.

## 인덱스
Local Secondary Index, LSI 로컬 보조 인덱스는 해당 파티션에 대해 생성된다. Global Secondary Index, GSI 글로벌 보조 인덱스는 파티션과 별도로 저장되고 관리되며 전체 테이블을 인덱싱한다. (한 파티션에 종속되는 것이 아니다.)

## 검색
DynamoDB의 검색 방법에는 2가지가 있다.
- Scan 스캔
- Query 쿼리

### 스캔
스캔은 파티션 키를 지정하지 않기 때문에 모든 파티션의 모든 항목을 탐색한다. 다소 비효율적이다.

### 쿼리
쿼리는 단일 파티션 키에 속한 모든 항목을 탐색하고 최대 1MB 제한을 초과하면 다음 페이지로 넘어갈 수 있는 LastEvaluatedKey를 제공한다. 쿼리 요청은 쿼리가 단일 파티션에 대해 실행되고 정렬 키를 지정할 수도 있기 때문에 스캔보다 효율적이고 빠르다. 그래서 가능한 스캔 작업대신 쿼리를 사용하는게 좋다. 

## DynamoDB Streams
DynamoDB 테이블의 변경사항(INSERT, DELETE, MODIFY)에 대한 정보들을 스트림 형태로 처리할 수 있도록 해주는 기능이다. 람다와 연동해서 데이터를 다른 곳(예를 들면 ElasticSearch)으로 동기화하는 기능에 자주 사용된다.

## 핫 파티션, 핫 키
DynamoDB를 사용할 땐 데이터가 여러 파티션에 고르게 분산되어야 한다. 파티션이 분산되는 기준은 다음과 같다.
- 파티션 키의 카디널리티
- 파티션의 용량이 100GB 이상
- 파티션의 RCU가 3000 이상
- 파티션의 WCU가 1000 이상
예를 들어, 한 파티션의 용량이 100GB가 되는 경우 파티션이 분할되며, 한 파티션에 요청이 집중되어 4000RCU를 수신하는 경우 파티션이 분할된다. 테이블을 설계할 때 파티션 키를 카디널리티가 높게 구성하여 파티션을 잘 분산시켜야 한다. 카디널리티는 특정 데이터 집합의 유니크한 값의 개수다. 예를 들어, 데이터베이스에 성별 컬럼의 경우 남자와 여자라는 값을 가진다. 이 경우 카디널리티는 2이다. 성별 컬럼을 파티션 키로 잡을 경우 모든 요청이 단 두개의 파티션에 몰리니 좋지 않은 설계다.  

그러나 데이터가 여러 파티션에 고르게 분산되어 있더라고 해도, 사용자의 요청이 특정 파티션에 몰리는 경우가 발생할 수 있다. 특정 파티션이 다른 파티션보다 더 많은 요청이 받게 될 경우, 결국 할당된 처리량을 초과해서 제한(쓰로틀링)된다. 이런 파티션을 핫 파티션이라 부른다. 이 경우 쓰기 샤딩이라는 방법을 사용해볼 수 있다. 이 방법은 파티션 키 값에 난수를 추가하여 파티션 간에 솔트 값을 추가하는 방식이다. 그럼 하나의 파티션 키에 대해 더 잘게 나뉘기 때문에 핫 파티션을 줄일 수 있다. 주의해야 할 것은 지정된 파티션 키에 대한 모든 항목을 검색해야 하는 경우, 이 방법이 비효율적일 수 있다. 단일 파티션 키에 속한 데이터가 여러 파티션에 분산되어 있는 경우 클라이언트에게 응답을 보내기 위해 서로 다른 파티션에 대해 읽기 요청을 실행하고 결과를 병합해야 할 것이다.  

사실 DynamoDB를 사용한다면 쓰로틀링을 아예 막을 수는 없다. 데이터를 아무리 잘 분산시켜도 사용자의 요청을 완벽하게 예측할 수는 없기 떄문이다. 그래서 DynamoDB를 사용하는 애플리케이션단에서 지수 백오프 Retry같은 로직이 필요하다. 내가 했던 프로젝트에서는 DynamoDB 테이블에 인서트할 때 지수 백오프를 적용하여 최대 3번까지 재시도하도록 구성했다.

## 참고
https://aws.amazon.com/dynamodb/  