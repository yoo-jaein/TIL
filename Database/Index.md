# Index

## 데이터베이스 인덱스
DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. 인덱스는 책의 맨 끝에 있는 찾아보기 또는 색인에 비유된다. 책의 내용을 모두 확인해서 원하는 내용을 발견하려면 시간이 오래 걸린다. DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 하나 이상의 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-value)으로 삼아서 인덱스를 만들어 둔다. 책의 색인이 'ㄱ', 'ㄴ', 'ㄷ' 순으로 정렬되어 있는 것 처럼 DBMS의 인덱스도 컬럼의 값을 미리 정렬해서 보관한다. 데이터가 추가될 때마다 항상 값을 정렬해야 하므로 INSERT, UPDATE, DELETE 문장의 처리가 느려진다. 하지만 SELECT 문장은 아주 빠르게 처리할 수 있다.

## 인덱스 기본 구조
### B-Tree 인덱스
- B-Tree 인덱스는 가장 일반적으로 사용되는 인덱스 알고리즘이다. 
- B-Tree의 B는 Balanced를 의미한다. 
- B-Tree 인덱스는 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱한다.
- B-Tree는 트리 구조 최상위에 하나의 "루트 노드(Root node)"가 존재하고 가장 하위에 "리프 노드(Leaf node)"가 붙어있다. 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 "브랜치 노드(Branch node)"라고 한다. 
- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 인덱스의 리프 노드는 실제 데이터 레코드의 주솟값을 가진다. 참고로 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 임의의 순서로 저장되어 있다. 레코드가 삭제되어 빈 공간이 생기면 그다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계되어 있다.

- InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다. 인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다. 
- InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.


- Root에서 Leaf 블록까지 거리를 깊이(Height)라고 하며, 인덱스의 반복적 탐색 시 성능에 영향을 미침
- Root/Branch 블록은 각 하위 노드들의 데이터 값 범위를 나타내는 키 값과 키 값에 해당하는 블록을 찾는데 필요한 주소 정보를 가짐
- Leaf 블록은 인덱스 키 값과, 그 키 값에 해당하는 테이블 레코드를 찾아가기 위한 주소 정보(ROWID)를 가짐
- 같은 키 값일 때는 ROWID 순으로 정렬
- 인덱스 키(Key)값 순으로 정렬되어 있기 때문에 범위 스캔(Range Scan)이 가능하고, 정방향/역방향(ASC/DESC) 스캔이 가능한 양방향 연결 리스트 구조

## 인덱스의 종류
### B-Tree 인덱스
OLTP(Online Transaction Processing) 실시간으로 데이터 입력과 수정이 일어나는 환경에 많이 사용

#### Unique Index
인덱스 안에 있는 컬럼 키 값에 중복되는 데이터가 없음

#### Non Unique Index
인덱스 안에 있는 컬럼 키 값에 중복되는 데이터가 존재함

#### FBI(Function Based Index)
컬럼에 특정 함수를 적용한 값으로 B-Tree 인덱스 생성

#### Descending Index
내림차순으로 인덱스 생성

#### Composite Index
두 개 이상의 컬럼을 합쳐서 인덱스를 생성

### 클러스터 인덱스
- 인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현
- 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안
- 클러스터드 인덱스는 테이블의 기본키에 대해서만 적용된다.
- 기본키 값이 비슷한 레코드끼리 묶어서 저장한다.

#### 클러스터링
디스크로부터 데이터를 읽어오는 시간을 줄이기 위해 조인이나 자주 사용되는 테이블의 데이터를 디스크의 같은 위치에 저장시키는 방법

#### 장점
- 그룹된 컬럼 데이터 행들이 같은 데이터 Block에 저장되기 때문에 디스크 I/O를 줄임
클러스터된 테이블 사이에 조인이 발생할 경우 처리 시간이 단축
클러스터 키 열을 공유해 한 번만 저장하므로 저장 영역의 사용을 줄임

#### 특징
데이터 조회 성능을 향상시키지만 저장, 삭제, 수정 또는 Table Full Scan 성능을 감소 시킴

#### 클러스터하기 좋은 테이블
주로 조회가 자주 발생하고 수정이 거의 발생하지 않는 테이블
컬럼 안의 많은 중복 데이터를 가지는 테이블
자주 Join되는 테이블

#### 클러스터 Key가 되기 좋은 컬럼
데이터 값의 범위가 큰 컬럼
테이블 간의 조인에 사용되는 컬럼

#### 클러스터 Key가 되기 나쁜 컬럼
특정 데이터 값이 적은 칼럼
자주 데이터 수정이 발생하는 컬럼

### 해시 인덱스
- 컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘이다. 
- 매우 빠른 검색을 지원하지만 값을 변형해서 인덱싱하기 때문에 prefix 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 Hash 인덱스를 사용할 수 없다. 
- 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

## 참고
Real MySQL 8.0 1권 8장  