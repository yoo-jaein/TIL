# JPA FetchType
객체는 객체 그래프로 연관된 객체들을 탐색하지만, 데이터베이스는 실행하는 SQL에 따라 어디까지 탐색할 수 있는지가 정해진다. JPA는 이 불일치 문제를 해결하기 위해 프록시 기술로 연관된 엔티티를 조회하는 시점을 조절할 수 있다. 연관된 엔티티를 조회하는 시점에는 즉시 로딩과 지연 로딩이 있다.

## 즉시 로딩
- 즉시 로딩(Eager Loading)이란 엔티티를 조회할 때 연관된 엔티티도 함께 조회하는 것이다.
- @ManyToOne(fetch = FetchType.EAGER)로 설정한다.
- Hibernate는 다대일, 일대일 관계에서 @JoinColumn(nullable = true) 외래 키에 null 값을 허용하는 경우 (기본 값) LEFT OUTER JOIN을 하고, null 값을 허용하지 않는 경우 INNER JOIN을 사용한다.

### 컬렉션과 즉시 로딩
- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다. 컬렉션을 조인하는 것은 일대다 조인이고, 결과 데이터가 다 쪽에 있는 수만큼 증가한다. 
- 만약 서로 다른 컬렉션을 2개 이상 조인하는 경우, A 테이블을 N, M 두 테이블과 일대다 조인하면 실행 결과는 N * M이 되면서 너무 많은 데이터가 반환되고 애플리케이션 성능이 저하될 수 있다.
- 컬렉션의 즉시 로딩은 항상 OUTER JOIN을 사용한다. 즉, 일대다, 다대다 관계에서는 외래 키에 null 값을 허용하든 허용하지 않든 항상 OUTER JOIN이 발생한다는 것이다. Team 테이블에서 Member 테이블로 일대다 관계를 조인할 때 회원이 한 명도 없는 팀을 INNER JOIN한다면 팀이 조회되지 않는 문제가 발생한다. 따라서 JPA는 일대다 관계를 즉시 로딩할 때 항상 OUTER JOIN을 사용한다.

## 지연 로딩
- 지연 로딩(Lazy Loading)이란 연관된 엔티티를 실제 사용할 때 조회하는 것이다.
- @ManyToOne(fetch = FetchType.LAZY)로 설정한다.
- JPA는 지연 로딩을 구현하기 위해 프록시 기술을 사용한다.
  ```java
  em.find(Member.class, "member1"); //데이터베이스를 바로 조회한다.
  em.getReference(Member.class, "member1"); //데이터베이스 접근을 위임한 프록시 객체를 반환한다. (데이터베이스 조회 X, 엔티티 객체 생성 X)
  ```
- 프록시 클래스는 실제 클래스를 상속 받아서 만들어지고, 그 클래스와 겉모습이 같다. 프록시 객체는 실제 객체에 대한 참조를 보관하고 있어서 프록시 객체의 메서드가 호출되면 실제 객체의 메서드를 반환해준다.
- 프록시 객체는 member.getName()처럼 실제 사용될 때 데이터베이스를 조회해서 엔티티 객체를 생성하는데, 이를 프록시 객체의 초기화라고 한다.
- 참고로 만약 영속성 컨텍스트에 찾는 엔티티가 이미 있다면 getReference()는 프록시가 아닌 실제 엔티티를 반환한다.

### 컬렉션과 지연 로딩
- 엔티티를 지연 로딩하면 프록시 객체를 이용해서 지연 로딩을 수행한다. 이와 유사하게 컬렉션은 컬렉션 래퍼(wrapper)가 지연 로딩을 처리해준다.
- Hibernate는 컬렉션 래퍼로 PersistentBag을 제공한다.
- 컬렉션 래퍼도 컬렉션에 대한 일종의 프록시 역할을 하기 때문에 프록시로 불린다.
  ```java
  member.getOrders(); //컬렉션은 아직 초기화되지 않는다.
  member.getOrders.get(0); //이때 데이터베이스를 조회해서 컬렉션을 초기화한다.
  ```

## JPA 기본 페치 전략
JPA의 기본 페치 전략은 연관된 엔티티가 하나일 때 즉시 로딩, 컬렉션일 때 지연 로딩을 사용한다. 컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩해서 애플리케이션의 성능을 저하시킬 수 있기 때문이다.
- @ManyToOne, @OneToOne : 즉시 로딩
- @OneToMany, @ManyToMany : 지연 로딩
참고로 모든 연관관계에 지연 로딩을 사용하고 꼭 필요한 곳에서만 즉시 로딩을 사용하는 것이 좋다.

## 참고
자바 ORM 표준 JPA 프로그래밍 8장  