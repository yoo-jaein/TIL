# JPA and ORM

## JPA
JPA(Java Persistence API)는 자바 ORM 기술에 대한 API 표준 명세다. 쉽게 이야기하면 인터페이스를 모아둔 것이다. 따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다.

## 표준에서 오는 장점
특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있다. 따라서 JPA 표준을 먼저 이해하고 필요에 따라 JPA 구현체의 고유한 기능을 학습하면 된다.

## ORM
ORM(Object-Relation Mapping)은 객체와 관계형 데이터베이스를 매핑하는 것이다. ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임 불일치를 해결해준다. 자바 진영에는 ORM 프레임워크로 Hibernate가 가장 많이 사용된다. ORM 프레임워크를 사용하면 객체를 데이터베이스에 저장할 때 Insert SQL을 직접 작성하는 것이 아니라, 객체를 ORM 프레임워크에 저장하면 된다. 그러면 ORM 프레임워크가 적절한 Insert SQL을 생성해서 데이터베이스에 객체를 저장해준다.

## 객체와 관계형 데이터베이스의 패러타임 불일치 문제와 해결법

### 1. 상속
객체는 상속이라는 기능을 가지고 있지만 데이터베이스 테이블에는 상속이 없다. 데이터베이스 모델링에서 이야기하는 슈퍼타입-서브타입 관계를 사용하면 객체 상속과 가장 유사한 형태로 테이블을 설계할 수 있다. 

자식 객체를 데이터베이스에 저장하려면, 부모 객체에서 부모 데이터만 꺼내서 부모용 Insert SQL을 작성하고, 자식 객체에서 자식 데이터만 꺼내서 자식용 Insert SQL을 작성해야 한다.  

자식 객체를 조회한다면, 부모 테이블과 자식 테이블을 조인해서 조회한 다음, 그 결과로 자식 객체를 생성해야 한다.  

---

JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해준다. 개발자는 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 된다. 그러면 JPA가 앞서 설명한 일련의 과정을 대신 처리해준다.

### 2. 연관관계

객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다. 객체는 참조가 있는 방향으로만 조회할 수 있다.  

테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다. 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.  

---

객체지향 모델링. 개발자가 중간에서 변환 역할을 해야 한다.  

객체를 데이터베이스에 저장하려면 team 필드를 TEAM_ID 외래 키 값으로 변환해야 한다.  

---

JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다. 개발자는 회원과 팀의 관계를 설정하고 회원 객체를 저장하면 된다. JPA는 team의 참조를 외래 키로 변환해서 적절한 Insert SQL을 데이터베이스에 전달한다. 객체를 조회할 때 외래 키를 참조로 변환하는 일도 JPA가 처리해준다.

### 3. 객체 그래프 탐색

객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다.  

SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다. 어디까지 객체 그래프 탐색이 가능한지 알아보려면 DAO를 열어서 SQL을 직접 확인해야 한다.   

---

JPA를 사용하면 객체 그래프를 마음껏 탐색할 수 있다.

JPA는 연관된 객체를 사용하는 시점에 적절한 Select SQL을 실행한다. 이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 지연 로딩(lazy loading)이라 한다.   

만약 Member를 사용할 때마다 Order를 함께 사용하면, 지연 로딩으로 한 테이블씩 조회하는 것보다는 Member를 조회하는 시점에 SQL 조인을 사용해서 Member와 Order를 함께 조회하는 것이 효과적이다. JPA는 연관된 객체를 즉시 함께 조회할지 아니면 지연해서 조회할지를 간단한 설정으로 정의할 수 있다. 만약 Member와 Order를 즉시 함께 조회하겠다고 설정하면 JPA는 Member를 조회할 때 조인을 사용해서 연관된 Order도 함께 조회한다.

### 4. 비교

객체는 동일성(identity) 비교와 동등성(equality) 비교로 객체를 구분한다.

동일성 비교는 == 비교다. 객체 인스턴스의 주소 값을 비교한다.  
등등성 비교는 equals() 메서드를 사용해서 객체 내부의 값을 비교한다.  

데이터베이스는 기본 키의 값으로 각 로우를 구분한다.  

---

JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다. 이는 동일성 비교에 해당한다.  


## 왜 JPA를 사용해야 하는가?
JPA를 쓰면 무엇이 좋을까?
1. 생산성 : JPA를 사용하면 다음 코드처럼 자바 컬렉션에 객체를 저장하듯이 JPA에게 데이터베이스에 저장할 객체를 전달하면 된다. SQL을 작성하고 JDBC API를 사용하는 반복적인 일은 JPA가 개발자 대신 처리해준다.
    ```java
    jpa.persist(member); //저장
    Member member = jpa.find(memberId); //조회
    ```
2. 유지보수 : SQL을 직접 다루면 엔티티에 필드를 하나만 추가해도 관련된 등록/수정/조회 SQL과 결과 매핑을 위한 JDBC API 코드를 모두 변경해야 한다. 반면에 JPA를 사용하면 이런 과정을 JPA가 대신 처리해주므로 수정해야 할 코드가 줄어든다. 따라서 유지보수해야 하는 코드 수가 줄어든다.
3. 패러다임의 불일치 해결 : 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 JPA가 해결해준다.
4. 성능 : JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다. 예를 들어 동일한 트랜잭션 안에서 같은 회원을 두 번 조회한다면, JDBC API로 작성한 코드는 데이터베이스와 두 번 통신해야 하지만 JPA는 데이터베이스에 한 번만 SQL을 전달하고 두 번째에는 조회한 회원 객체를 재사용한다.
5. 벤더 독립성 : 관계형 데이터베이스는 벤더마다 사용법이 다른 경우가 많다. JPA는 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다. 데이터베이스를 교체할 일은 많이 없지만, 만약 데이터베이스를 변경해야 한다면 JPA에게 다른 데이터베이스를 사용한다고 알려주기만 하면 된다.
6. 표준 : ORM 기술 표준이기 때문에 사용한다. 표준을 사용하면 다른 구현 기술로 손쉽게 바꿀 수 있다.

## JPA가 적합하지 않은 경우는?
굉장히 복잡한 쿼리 또는 프로시저가 많은 시스템에는 적합하지 않다. ORM의 객체 지향적인 장점을 활용하기 어렵다.

## JPA를 썼을 때 성능이 느려지진 않을까?
JPA 자체로 인한 성능 저하 이슈는 거의 없다. JPA는 다양한 성능 최적화 기능을 제공하는데 그 기능을 잘 이해하고 사용하면 SQL을 직접 사용할 때보다 더 좋은 성능을 낼 수 있다. 하지만 JPA를 잘 이해하지 못하고 사용하면 N+1 같은 문제로 심각한 성능 저하가 발생할 수 있다.

## N+1 문제
N+1 문제는 SQL 1번으로 회원 100명을 조회했는데, 각 회원마다 주문한 상품을 추가로 조회하기 위해 100번의 SQL을 추가로 실행하는 것을 말한다. 한 번 SQL을 실행해서 조회한 수 만큼 N번 SQL을 추가로 실행한다고 해서 N+1 문제라고 한다. N+1 문제를 해결하는 가장 일반적인 방법은 페치 조인을 사용하는 것이다. 페치 조인은 SQL 조인을 사용해서 연관된 엔티티를 함께 조회하므로 N+1 문제가 발생하지 않는다.

```mysql-sql
-- JPQL
select m from Member m join fetch m.orders;

-- SQL
select m.*, o.* from member m
inner join orders o on m.id = o.member_id;
```

## 마이바티스와 ORM의 차이
마이바티스나 JdbcTemplate을 객체와 SQL을 매핑해주는 SQL 매퍼라 한다. SQL과 매핑할 객체만 지정하면 반복적인 JDBC API 사용과 응답 결과 매핑을 SQL 매퍼가 대신 처리해준다.  

SQL 매퍼가 편리하긴 하지만 결국 개발자가 SQL을 직접 작성해야 하기 때문에 SQL에 의존하는 개발이 된다. ORM의 경우 객체와 테이블을 매핑만하면 ORM 프레임워크가 SQL을 만들어서 데이터베이스와 관련된 처리를 해주기 때문에 SQL에 의존하는 개발을 피할 수 있다.  

## 참고
자바 ORM 표준 JPA 프로그래밍  
https://ict-nroo.tistory.com/117  